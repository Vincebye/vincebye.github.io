<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on The Space Between Us</title>
    <link>https://vincebye.github.io/posts/</link>
    <description>Recent content in Posts on The Space Between Us</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 16 Apr 2023 18:02:42 +0800</lastBuildDate><atom:link href="https://vincebye.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Rust调用C代码</title>
      <link>https://vincebye.github.io/posts/rust%E8%B0%83%E7%94%A8c%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Sun, 16 Apr 2023 18:02:42 +0800</pubDate>
      
      <guid>https://vincebye.github.io/posts/rust%E8%B0%83%E7%94%A8c%E4%BB%A3%E7%A0%81/</guid>
      <description>#Rust
Rust 可以通过外部函数接口调用（Foreign Function Interface, FFI）来调用 C 代码。FFI 是一种通用的机制，可以使不同语言之间的函数相互调用。在 Rust 中，使用 FFI 机制可以调用 C 语言编写的库。 具体来说，Rust 通过以下步骤来调用 C 代码：
在 Rust 代码中声明 C 函数签名：在 Rust 代码中声明一个函数签名，其参数和返回值应该与 C 代码中的函数签名一致。这个函数签名可以使用 extern &amp;quot;C&amp;quot; 关键字进行声明，这样 Rust 就可以使用 C 语言的调用约定来调用这个函数。 使用 Rust 绑定链接 C 库：在 Rust 代码中使用 extern crate 或 use 关键字来引用 C 库的 Rust 绑定，使得 Rust 可以访问 C 库中的函数和类型定义。 在 Rust 代码中调用 C 函数：在 Rust 代码中使用声明的 C 函数签名来调用 C 函数。在调用之前，需要使用 unsafe 关键字将代码块标记为不安全的，因为在调用 C 函数时，Rust 编译器无法保证代码的安全性。 在 Rust 中调用外部 C 代码时，需要将 C 代码编译成 Rust 可以链接的静态库或动态库。这是因为 Rust 代码和 C 代码使用的编译器和链接器可能不同，需要通过编译成中间格式的静态库或动态库来进行链接。在 Rust 中，可以使用 cc crate 来编译 C 代码并生成静态库或动态库。在上述代码中，cc::Build::new().</description>
    </item>
    
    <item>
      <title>Winafl使用记录</title>
      <link>https://vincebye.github.io/posts/winafl%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Fri, 14 Apr 2023 16:01:06 +0800</pubDate>
      
      <guid>https://vincebye.github.io/posts/winafl%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</guid>
      <description>[[#测试DynamoRIO是否插桩成功|测试DynamoRIO是否插桩成功]] [[#乱乱写|乱乱写]] [[#Patch程序|Patch程序]] [[#监控CPU占用|监控CPU占用]] [[#命令行Fuzzing|命令行Fuzzing]] [[#命令行Fuzzing#问题|问题]] [[#DLL Fuzzing|DLL Fuzzing]] [[#Harness|Harness]] [[#思路|思路]] 安装&amp;amp;使用说明 cmake
-G &amp;lt;generator-name&amp;gt; 指定构建系统生成器。 CMake可能在某些平台上支持多个本机构建系统。生成器负责生成特定的构建系统。可能的生成器名称在 cmake-generators(7) 手册。 如果未指定，CMake将检查 CMAKE_GENERATOR 环境变量，否则将退回到内置的默认选择。 -A &amp;lt;platform-name&amp;gt; 如果生成器支持，请指定平台名称。 一些CMake生成器支持将平台名称提供给本机构建系统以选择编译器或SDK。见 CMAKE_GENERATOR_PLATFORM 变量以获取详细信息。 下载 WINAFL：https://github.com/googleprojectzero/winafl
下载DynamoRIO：https://github.com/DynamoRIO/dynamorio/releases
下载后把二者解压到同一文件夹下，如 Fuzzing，手动编译 x64环境
I:\\Fuzzing&amp;gt;cd winafl I:\\Fuzzing\\winafl&amp;gt;mkdir build64 I:\\Fuzzing\\winafl&amp;gt;cd build64 if VS2022 cmake -G &amp;#34;Visual Studio 17 2022&amp;#34; -A x64 .. -DDynamoRIO_DIR=D:\\fuzzing\\DynamoRIO\\cmake -DUSE_COLOR=1 cmake --build . --config Release if VS2019 cmake -G&amp;#34;Visual Studio 16 2019&amp;#34; -A x64 .. -DDynamoRIO_DIR=I:\\Fuzzing\\dynamorio\\cmake cmake --build .</description>
    </item>
    
    <item>
      <title>Pin学习记录</title>
      <link>https://vincebye.github.io/posts/pin%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Thu, 13 Apr 2023 16:34:00 +0800</pubDate>
      
      <guid>https://vincebye.github.io/posts/pin%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</guid>
      <description>#插桩
环境 windows Make&amp;amp;GCC&amp;amp;G++
安装cygwin
安装勾选gcc-core g++ make 在devel类别里
然后将bin目录加入path
编译测试项目
64位
使用x64 Native Tools Command Prompt for VS 2019
cd C:\\pin\\source\\tools\\ManualExamples make all TARGET=intel64 32位
使用x86 Native Tools Command Prompt for VS 2019，修改C:\pin\source\tools\Config\win.vars中添加一行 cd C:\\pin\\source\\tools\\ManualExamples make all VS集成Pin 在VS中选择工具→外部工具→Add
运行 Examples Simple Instruction Count （指令插桩） 统计执行过的指令的总数
/* * Copyright (C) 2004-2021 Intel Corporation. * SPDX-License-Identifier: MIT */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;#34;pin.H&amp;#34; using std::cerr; using std::endl; using std::ios; using std::ofstream; using std::string; ofstream OutFile; // The running count of instructions is kept here // make it static to help the compiler optimize docount static UINT64 icount = 0; // This function is called before every instruction is executed //每个指令执行之前运行这个函数 VOID docount() { icount++; } // Pin calls this function every time a new instruction is encountered //每遇到一条指令，运行一次这个函数 VOID Instruction(INS ins, VOID* v) { // Insert a call to docount before every instruction, no arguments are passed //在每条指令运行之前插入一个函数来计数，没有参数传递 INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_END); } KNOB&amp;lt; string &amp;gt; KnobOutputFile(KNOB_MODE_WRITEONCE, &amp;#34;pintool&amp;#34;, &amp;#34;o&amp;#34;, &amp;#34;inscount.</description>
    </item>
    
    <item>
      <title>IDAPython自动化代码</title>
      <link>https://vincebye.github.io/posts/idapython%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Wed, 12 Apr 2023 15:22:00 +0800</pubDate>
      
      <guid>https://vincebye.github.io/posts/idapython%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BB%A3%E7%A0%81/</guid>
      <description>#IDA
单个脚本执行
C:\\Study\\BinaryAnalyse&amp;gt;C://Pwn/IDA/ida64.exe -LC:/mylog.log -c -A -S&amp;#34;C://Study/BinaryAnalyse/analyse.py&amp;#34; C://Study/BinaryAnalyse/datas/crackme0x03.exe PS:Windows注意-S后的脚本名称需要添加双引号
c 表示对要分析的二进制文件生成一个新的IDB文件。 -A表示以autonomous模式运行，如果不加这个选项，则会弹出图形界面。 -S 制定要执行的 plugin script。 批量执行
//analyse.py import idc import idautils import idaapi from collections import defaultdict def analysis(): pass # 这里是分析的代码 def main(): &amp;#34;&amp;#34;&amp;#34; 控制器 &amp;#34;&amp;#34;&amp;#34; idc.auto_wait() # 等IDA分析完后才执行 analysis() idc.qexit(0) # 关闭IDA if __name__ == &amp;#34;__main__&amp;#34;: main() 批量
//run.py # -*- coding:utf-8 -*- # =======Import ======= import os import subprocess #C:\\Study\\BinaryAnalyse\\datas #C:\\Pwn\\IDA Pro 7.6 dir_path = &amp;#34;C://Study/BinaryAnalyse/datas/&amp;#34; # 原始数据的文件夹 ida64_path = &amp;#34;C://Pwn/IDA/ida64.</description>
    </item>
    
    <item>
      <title>LibAFL Introduce</title>
      <link>https://vincebye.github.io/posts/libafl-introduce/</link>
      <pubDate>Wed, 12 Apr 2023 00:38:17 +0800</pubDate>
      
      <guid>https://vincebye.github.io/posts/libafl-introduce/</guid>
      <description>#Fuzzer #Rust
序 前置知识 Rust Fuzzing LibAFL介绍 LibAFL：为了解决大量的fuzzer工具重复工作的问题，将fuzzer拆分成多个部分，编写fuzzer只需要将其组装，如输入可以改成字节输入或者AST输入，不需要重新安装熟悉多个fuzzer。缺点就是Rust门槛比较高。
资源 LibAFL Book：https://aflplus.plus/libafl-book/libafl.html 项目：https://github.com/AFLplusplus/LibAFL
正文 baby_fuzzer 官方给出的一个简单案例用来说明如何使用LibAFL，我们摘取一部分,以下就是一个简单的fuzzer代码，看着很复杂，不如直接AFL++一把梭。
// Create an observation channel using the signals map let observer = unsafe { StdMapObserver::from_mut_ptr(&amp;#34;signals&amp;#34;, SIGNALS_PTR, SIGNALS.len()) }; // Feedback to rate the interestingness of an input let mut feedback = MaxMapFeedback::new(&amp;amp;observer); // A feedback to choose if an input is a solution or not let mut objective = CrashFeedback::new(); // create a State from scratch let mut state = StdState::new( // RNG StdRand::with_seed(current_nanos()), // Corpus that will be evolved, we keep it in memory for performance InMemoryCorpus::new(), // Corpus in which we store solutions (crashes in this example), // on disk so the user can get them after stopping the fuzzer OnDiskCorpus::new(PathBuf::from(&amp;#34;.</description>
    </item>
    
  </channel>
</rss>
